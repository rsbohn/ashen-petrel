# Dev Log - 2026-01-10 (Euler 01)

Euler 01 ended up being a forcing function for Ashen Petrel. It pushed the ISA
beyond toy stack ops into real program behavior: we had to formalize the
two-opcode word model, define register stack semantics, add full-word
immediates, and build a working file assembler. Each time the program stalled
or misbehaved, it exposed a missing primitive (e.g., proper DIV stack effects,
TEST for CC, conditional branches, and carry/overflow handling), and we
iterated until the program became expressible.

It also validated the monitor UX. We had to make trace practical, fix
disassembly formatting, ensure octal output everywhere, and add label
resolution to the assembler. These are the kinds of sharp edges that only show
up when you run a nontrivial program end-to-end.

Most importantly, Euler 01 gave us a concrete correctness target. Seeing TOTAL
converge—and using flags to detect overflow and tune MAX—confirmed the machine
model is coherent. The exercise made the emulator feel like an actual machine,
not just a scaffold. It became both a spec and a test harness. 

We also tightened stack spill behavior. When more than four values live on the
stack, pops now keep SR pinned at 4 while refilling from spill memory; only
once the spill is drained does SR start to drop. This fixed a stack underflow
triggered by DUP after spill-heavy code and added a regression test to lock it
in.

Euler 01 got two logic fixes as well: the SUM path now routes back through
DXBZ so the loop counter decrements on every iteration, and MAX was adjusted
to 01747 (octal 999) to match the "below 1000" requirement. The program now
halts with TOTAL = 000003:107320 as expected.
